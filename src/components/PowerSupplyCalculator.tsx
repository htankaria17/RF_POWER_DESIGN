import React, { useState, useEffect } from 'react';
import {
  Typography,
  Grid,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Paper,
  Box,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Button,
  Tabs,
  Tab,
  Divider,
} from '@mui/material';
import {
  Download as DownloadIcon,
  SchemaOutlined as SchemaIcon,
} from '@mui/icons-material';

interface PowerSupplyResults {
  inductance: number;
  outputCapacitor: number;
  inputCapacitor: number;
  feedbackR1: number;
  feedbackR2: number;
  currentSenseR: number;
  efficiency: number;
  rippleVoltage: number;
  rippleCurrent: number;
}

const PowerSupplyCalculator: React.FC = () => {
  const [topology, setTopology] = useState('buck');
  const [inputVoltage, setInputVoltage] = useState(12);
  const [outputVoltage, setOutputVoltage] = useState(5);
  const [outputCurrent, setOutputCurrent] = useState(2);
  const [frequency, setFrequency] = useState(100000);
  const [ripplePercent, setRipplePercent] = useState(5);
  const [results, setResults] = useState<PowerSupplyResults | null>(null);
  const [tabValue, setTabValue] = useState(0);

  const calculatePowerSupply = () => {
    const Po = outputVoltage * outputCurrent;
    const dutyCycle = topology === 'buck' ? outputVoltage / inputVoltage : 
                      topology === 'boost' ? 1 - inputVoltage / outputVoltage :
                      0.5; // Default for flyback/forward

    // Inductor calculation (Henry)
    const deltaIL = outputCurrent * (ripplePercent / 100);
    const inductance = topology === 'buck' ? 
      (inputVoltage - outputVoltage) * dutyCycle / (deltaIL * frequency) :
      inputVoltage * dutyCycle / (deltaIL * frequency);

    // Output capacitor (Farad)
    const deltaVo = outputVoltage * (ripplePercent / 100);
    const outputCapacitor = deltaIL / (8 * frequency * deltaVo);

    // Input capacitor (Farad)
    const inputCapacitor = outputCurrent * dutyCycle / (frequency * inputVoltage * 0.01);

    // Feedback resistors (Ohm) - for 1.25V reference
    const vRef = 1.25;
    const feedbackR2 = 10000; // 10kΩ typical
    const feedbackR1 = feedbackR2 * (outputVoltage / vRef - 1);

    // Current sense resistor (Ohm)
    const currentSenseR = 0.1; // 100mΩ typical

    // Efficiency estimation
    const conductionLoss = Math.pow(outputCurrent, 2) * 0.1; // Simplified
    const switchingLoss = 0.5 * inputVoltage * outputCurrent * 1e-9 * frequency;
    const totalLoss = conductionLoss + switchingLoss;
    const efficiency = (Po / (Po + totalLoss)) * 100;

    // Ripple calculations
    const rippleVoltage = deltaVo;
    const rippleCurrent = deltaIL;

    setResults({
      inductance: inductance * 1e6, // Convert to µH
      outputCapacitor: outputCapacitor * 1e6, // Convert to µF
      inputCapacitor: inputCapacitor * 1e6, // Convert to µF
      feedbackR1,
      feedbackR2,
      currentSenseR,
      efficiency,
      rippleVoltage,
      rippleCurrent,
    });
  };

  useEffect(() => {
    calculatePowerSupply();
  }, [topology, inputVoltage, outputVoltage, outputCurrent, frequency, ripplePercent]);

  const generateSpiceFile = () => {
    if (!results) return;

    const spiceContent = `* ${topology.toUpperCase()} Converter - Generated by RF Design Studio
* Input: ${inputVoltage}V, Output: ${outputVoltage}V@${outputCurrent}A
* Frequency: ${frequency/1000}kHz

.param Vin=${inputVoltage}
.param Vout=${outputVoltage}
.param Iout=${outputCurrent}
.param fs=${frequency}
.param L=${results.inductance}u
.param Cout=${results.outputCapacitor}u
.param Cin=${results.inputCapacitor}u

${getTopologySpice()}

* Analysis
.tran 0 {10/fs} 0 {1/fs/100}
.measure tran Vout_avg avg V(Vout) from {5/fs} to {10/fs}
.measure tran Vout_ripple pp V(Vout) from {5/fs} to {10/fs}
.measure tran IL_ripple pp I(L1) from {5/fs} to {10/fs}
.end`;

    const blob = new Blob([spiceContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${topology}_converter_${outputVoltage}V_${outputCurrent}A.asc`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const getTopologySpice = () => {
    switch (topology) {
      case 'buck':
        return `* Buck Converter Circuit
Vin Vin 0 {Vin}
L1 SW Vout {L}
Cout Vout 0 {Cout}
Rload Vout 0 {Vout/Iout}
Cin Vin 0 {Cin}

* MOSFET Switch Model (simplified)
S1 Vin SW GATE 0 SWITCH
VGATE GATE 0 PULSE(0 10 0 1n 1n {0.5/fs} {1/fs})

.model SWITCH SW(Ron=10m Roff=1Meg Vt=5 Vh=0.1)

* Diode
D1 0 SW DIODE
.model DIODE D(Is=1p Rs=10m Cjo=100p)`;

      case 'boost':
        return `* Boost Converter Circuit
Vin Vin 0 {Vin}
L1 Vin SW {L}
D1 SW Vout DIODE
Cout Vout 0 {Cout}
Rload Vout 0 {Vout/Iout}
Cin Vin 0 {Cin}

* MOSFET Switch Model
S1 SW 0 GATE 0 SWITCH
VGATE GATE 0 PULSE(0 10 0 1n 1n {0.6/fs} {1/fs})

.model SWITCH SW(Ron=10m Roff=1Meg Vt=5 Vh=0.1)
.model DIODE D(Is=1p Rs=10m Cjo=100p)`;

      case 'flyback':
        return `* Flyback Converter Circuit
Vin Vin 0 {Vin}
L1 Vin SW {L}
L2 Vout_D Vout {L*0.25} ; Secondary inductance
K1 L1 L2 0.95 ; Coupling coefficient
D1 Vout_D 0 DIODE
Cout Vout 0 {Cout}
Rload Vout 0 {Vout/Iout}
Cin Vin 0 {Cin}

* MOSFET Switch Model
S1 SW 0 GATE 0 SWITCH
VGATE GATE 0 PULSE(0 10 0 1n 1n {0.4/fs} {1/fs})

.model SWITCH SW(Ron=10m Roff=1Meg Vt=5 Vh=0.1)
.model DIODE D(Is=1p Rs=10m Cjo=100p)`;

      default:
        return `* Forward Converter Circuit
Vin Vin 0 {Vin}
L1 Vin SW {L}
L2 SW Vout {L*0.5} ; Secondary inductance  
K1 L1 L2 0.98 ; Coupling coefficient
D1 Vout VOUT_F DIODE
D2 0 SW DIODE ; Freewheeling diode
Cout VOUT_F 0 {Cout}
Rload VOUT_F 0 {Vout/Iout}
Cin Vin 0 {Cin}

* MOSFET Switch Model
S1 SW 0 GATE 0 SWITCH
VGATE GATE 0 PULSE(0 10 0 1n 1n {0.45/fs} {1/fs})

.model SWITCH SW(Ron=10m Roff=1Meg Vt=5 Vh=0.1)
.model DIODE D(Is=1p Rs=10m Cjo=100p)`;
    }
  };

  const getSchematic = () => {
    switch (topology) {
      case 'buck':
        return (
          <Box sx={{ p: 2, textAlign: 'center', bgcolor: '#f8f9fa', borderRadius: 1 }}>
            <Typography variant="subtitle1" gutterBottom><strong>Buck Converter Schematic</strong></Typography>
            <Box component="pre" sx={{ fontFamily: 'monospace', fontSize: '12px', lineHeight: 1.2 }}>
{`
    Vin                 L1              Vout
     +─────────┬────────ΛΛΛΛΛΛ────┬──────+
               │                   │
               │                   │
            ┌──S1──┐                Cout ┃
            │      │                     ┃
            │   GATE                     ┃
            │      │                     ┃
            └──────┤                     ┃
                   │                     │
                ┌──D1─┐                  │
                │  ▼  │                  │
                └─────┘                  │
                   │                     │
     ──────────────┴─────────────────────┴───────
                   0V (Ground)
                   
     Components:
     L1 = ${results?.inductance.toFixed(1)}µH
     Cout = ${results?.outputCapacitor.toFixed(1)}µF  
     D1 = Schottky Diode
     S1 = Power MOSFET
`}
            </Box>
          </Box>
        );

      case 'boost':
        return (
          <Box sx={{ p: 2, textAlign: 'center', bgcolor: '#f8f9fa', borderRadius: 1 }}>
            <Typography variant="subtitle1" gutterBottom><strong>Boost Converter Schematic</strong></Typography>
            <Box component="pre" sx={{ fontFamily: 'monospace', fontSize: '12px', lineHeight: 1.2 }}>
{`
    Vin           L1                    Vout
     +────────ΛΛΛΛΛΛ────┬──────D1───┬────+
                         │     ▲    │
                         │     │    │
                         │          Cout ┃
                      ┌──S1──┐           ┃
                      │      │           ┃
                      │   GATE           ┃
                      │      │           ┃
                      └──────┤           ┃
                             │           │
     ─────────────────────────┴───────────┴─────
                             0V (Ground)
                             
     Components:
     L1 = ${results?.inductance.toFixed(1)}µH
     Cout = ${results?.outputCapacitor.toFixed(1)}µF
     D1 = Schottky Diode
     S1 = Power MOSFET
`}
            </Box>
          </Box>
        );

      case 'flyback':
        return (
          <Box sx={{ p: 2, textAlign: 'center', bgcolor: '#f8f9fa', borderRadius: 1 }}>
            <Typography variant="subtitle1" gutterBottom><strong>Flyback Converter Schematic</strong></Typography>
            <Box component="pre" sx={{ fontFamily: 'monospace', fontSize: '12px', lineHeight: 1.2 }}>
{`
    Vin        Primary     │      Secondary        Vout
     +────────ΛΛΛΛΛΛ──●───┼───●──ΛΛΛΛΛΛ────D1────┬──+
               L1      │   │   │    L2      ▲     │
                       │   │   │            │     │
                    ┌──S1  │   │                  Cout ┃
                    │   │  │ T │                       ┃
                    │ GATE │ R │                       ┃
                    │   │  │ A │                       ┃ 
                    └───┤  │ N │                       ┃
                        │  │ S │                       │
     ───────────────────┴──●───┼───●───────────────────┴───
                              │       
                              0V (Ground)
                              
     Components:
     L1 = ${results?.inductance.toFixed(1)}µH (Primary)
     L2 = ${(results?.inductance * 0.25).toFixed(1)}µH (Secondary)
     Cout = ${results?.outputCapacitor.toFixed(1)}µF
     Turns Ratio = 2:1
`}
            </Box>
          </Box>
        );

      default:
        return (
          <Box sx={{ p: 2, textAlign: 'center', bgcolor: '#f8f9fa', borderRadius: 1 }}>
            <Typography variant="subtitle1" gutterBottom><strong>Forward Converter Schematic</strong></Typography>
            <Box component="pre" sx={{ fontFamily: 'monospace', fontSize: '12px', lineHeight: 1.2 }}>
{`
    Vin     Primary      │     Secondary         Vout
     +────ΛΛΛΛΛΛ──●─────┼─────●──ΛΛΛΛΛΛ──D1────┬──+
          L1       │     │     │   L2     ▲     │
                   │     │     │          │     │
                ┌──S1    │ T   │              Cout ┃
                │  │     │ R   │                   ┃
                │ GATE   │ A   │                   ┃
                │  │     │ N   │                   ┃
                └──┤     │ S   │                   ┃
                   │     │     │     D2            │
     ──────────────┴─────●─────┼─────●────D2───────┴───
                               │      ▲
                               0V (Ground)
                               
     Components:
     L1 = ${results?.inductance.toFixed(1)}µH (Primary)
     L2 = ${(results?.inductance * 0.5).toFixed(1)}µH (Secondary) 
     Cout = ${results?.outputCapacitor.toFixed(1)}µF
     D1 = Output Rectifier, D2 = Freewheeling Diode
`}
            </Box>
          </Box>
        );
    }
  };

  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        🔌 Power Supply Design Calculator
      </Typography>

      <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
        <Tabs value={tabValue} onChange={(e, newValue) => setTabValue(newValue)}>
          <Tab icon={<SchemaIcon />} label="Calculator" iconPosition="start" />
          <Tab icon={<SchemaIcon />} label="Schematic" iconPosition="start" />
        </Tabs>
      </Box>

      {tabValue === 0 && (
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 3, mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              SPICE Export
            </Typography>
            <Button
              variant="contained"
              startIcon={<DownloadIcon />}
              onClick={generateSpiceFile}
              disabled={!results}
              fullWidth
              sx={{ mb: 2 }}
            >
              Download LTspice File (.asc)
            </Button>
            <Typography variant="body2" color="text.secondary">
              Generate complete SPICE netlist with calculated component values for direct simulation in LTspice.
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6}>
          {/* Spacer for better layout */}
        </Grid>
      </Grid>
      )}

      {tabValue === 0 && (
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 3, mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              Input Parameters
            </Typography>
            
            <Grid container spacing={2}>
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Topology</InputLabel>
                  <Select
                    value={topology}
                    label="Topology"
                    onChange={(e) => setTopology(e.target.value)}
                  >
                    <MenuItem value="buck">Buck (Step-down)</MenuItem>
                    <MenuItem value="boost">Boost (Step-up)</MenuItem>
                    <MenuItem value="flyback">Flyback</MenuItem>
                    <MenuItem value="forward">Forward</MenuItem>
                  </Select>
                </FormControl>
              </Grid>

              <Grid item xs={6}>
                <TextField
                  fullWidth
                  label="Input Voltage (V)"
                  type="number"
                  value={inputVoltage}
                  onChange={(e) => setInputVoltage(Number(e.target.value))}
                />
              </Grid>

              <Grid item xs={6}>
                <TextField
                  fullWidth
                  label="Output Voltage (V)"
                  type="number"
                  value={outputVoltage}
                  onChange={(e) => setOutputVoltage(Number(e.target.value))}
                />
              </Grid>

              <Grid item xs={6}>
                <TextField
                  fullWidth
                  label="Output Current (A)"
                  type="number"
                  value={outputCurrent}
                  onChange={(e) => setOutputCurrent(Number(e.target.value))}
                />
              </Grid>

              <Grid item xs={6}>
                <TextField
                  fullWidth
                  label="Frequency (Hz)"
                  type="number"
                  value={frequency}
                  onChange={(e) => setFrequency(Number(e.target.value))}
                />
              </Grid>

              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Ripple Percentage (%)"
                  type="number"
                  value={ripplePercent}
                  onChange={(e) => setRipplePercent(Number(e.target.value))}
                />
              </Grid>
            </Grid>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          {results && (
            <Paper sx={{ p: 3, mb: 3 }}>
              <Typography variant="h6" gutterBottom>
                Component Values
              </Typography>
              
              <TableContainer>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell><strong>Component</strong></TableCell>
                      <TableCell><strong>Value</strong></TableCell>
                      <TableCell><strong>Unit</strong></TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    <TableRow>
                      <TableCell>Inductor</TableCell>
                      <TableCell>{results.inductance.toFixed(2)}</TableCell>
                      <TableCell>µH</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell>Output Capacitor</TableCell>
                      <TableCell>{results.outputCapacitor.toFixed(2)}</TableCell>
                      <TableCell>µF</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell>Input Capacitor</TableCell>
                      <TableCell>{results.inputCapacitor.toFixed(2)}</TableCell>
                      <TableCell>µF</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell>Feedback R1</TableCell>
                      <TableCell>{results.feedbackR1.toFixed(0)}</TableCell>
                      <TableCell>Ω</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell>Feedback R2</TableCell>
                      <TableCell>{results.feedbackR2}</TableCell>
                      <TableCell>Ω</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell>Current Sense R</TableCell>
                      <TableCell>{results.currentSenseR}</TableCell>
                      <TableCell>Ω</TableCell>
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            </Paper>
          )}

          {results && (
            <Paper sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                Performance Analysis
              </Typography>
              
              <TableContainer>
                <Table size="small">
                  <TableBody>
                    <TableRow>
                      <TableCell><strong>Efficiency</strong></TableCell>
                      <TableCell>{results.efficiency.toFixed(1)}%</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell><strong>Output Ripple Voltage</strong></TableCell>
                      <TableCell>{results.rippleVoltage.toFixed(3)} V</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell><strong>Inductor Ripple Current</strong></TableCell>
                      <TableCell>{results.rippleCurrent.toFixed(3)} A</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell><strong>Power Output</strong></TableCell>
                      <TableCell>{(outputVoltage * outputCurrent).toFixed(1)} W</TableCell>
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            </Paper>
          )}
        </Grid>
      </Grid>
      )}

      {tabValue === 1 && results && (
        <Box>
          {getSchematic()}
          <Box sx={{ mt: 3 }}>
            <Button
              variant="contained"
              startIcon={<DownloadIcon />}
              onClick={generateSpiceFile}
              sx={{ mr: 2 }}
            >
              Download SPICE File
            </Button>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              Complete netlist with {topology} topology and calculated component values
            </Typography>
          </Box>
        </Box>
      )}

      <Alert severity="info" sx={{ mt: 3 }}>
        <strong>Design Notes:</strong> Values are calculated using standard power electronics formulas. 
        Consider component tolerances, temperature coefficients, and safety margins in your final design.
        Always verify calculations with simulation before prototyping.
      </Alert>
    </Box>
  );
};

export default PowerSupplyCalculator;